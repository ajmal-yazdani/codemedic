using System.Diagnostics;
using System.Text.RegularExpressions;
using CodeMedic.Models;

namespace CodeMedic.Engines;

/// <summary>
/// Scans NuGet packages for known vulnerabilities using the dotnet CLI audit functionality.
/// </summary>
public class VulnerabilityScanner
{
    private readonly string _rootPath;
    private static readonly Dictionary<string, List<PackageVulnerability>> VulnerabilityCache = 
        new(StringComparer.OrdinalIgnoreCase);

    /// <summary>
    /// Initializes a new instance of the <see cref="VulnerabilityScanner"/> class.
    /// </summary>
    /// <param name="rootPath">The root directory of the repository being scanned.</param>
    public VulnerabilityScanner(string rootPath)
    {
        _rootPath = Path.GetFullPath(rootPath);
    }

    /// <summary>
    /// Scans a package for known vulnerabilities.
    /// </summary>
    /// <param name="packageName">The NuGet package name to scan.</param>
    /// <param name="packageVersion">The specific version to check.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    /// <returns>A list of vulnerabilities affecting this package version.</returns>
    public async Task<List<PackageVulnerability>> ScanPackageAsync(
        string packageName, 
        string packageVersion, 
        CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(packageName) || packageName.Equals("unknown", StringComparison.OrdinalIgnoreCase))
        {
            return [];
        }

        if (string.IsNullOrWhiteSpace(packageVersion) || packageVersion.Equals("unknown", StringComparison.OrdinalIgnoreCase))
        {
            return [];
        }

        try
        {
            // Check cache first
            if (VulnerabilityCache.TryGetValue(packageName, out var cached))
            {
                return cached.Where(v => VersionMatches(packageVersion, v.AffectedVersion)).ToList();
            }

            // Try using dotnet CLI audit tool
            var vulnerabilities = await ScanUsingDotnetAuditAsync(packageName, packageVersion, cancellationToken);
            
            // Cache result (even if empty)
            if (!VulnerabilityCache.ContainsKey(packageName))
            {
                VulnerabilityCache[packageName] = vulnerabilities;
            }

            return vulnerabilities;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Warning: Could not scan {packageName} for vulnerabilities: {ex.Message}");
            return [];
        }
    }

    /// <summary>
    /// Scans multiple packages for vulnerabilities.
    /// </summary>
    public async Task<Dictionary<string, List<PackageVulnerability>>> ScanPackagesAsync(
        List<Package> packages,
        CancellationToken cancellationToken = default)
    {
        var result = new Dictionary<string, List<PackageVulnerability>>();
        
        // Use semaphore to limit concurrent requests
        using var semaphore = new SemaphoreSlim(5); // Max 5 concurrent requests

        var tasks = packages.Select(async pkg =>
        {
            await semaphore.WaitAsync(cancellationToken);
            try
            {
                var vulns = await ScanPackageAsync(pkg.Name, pkg.Version, cancellationToken);
                var key = $"{pkg.Name}@{pkg.Version}";
                return (key, vulns);
            }
            finally
            {
                semaphore.Release();
            }
        });

        var scans = await Task.WhenAll(tasks);
        
        foreach (var (key, vulns) in scans)
        {
            result[key] = vulns;
        }

        return result;
    }

    /// <summary>
    /// Attempts to scan using the dotnet CLI audit tool.
    /// </summary>
    private async Task<List<PackageVulnerability>> ScanUsingDotnetAuditAsync(
        string packageName,
        string packageVersion,
        CancellationToken cancellationToken)
    {
        var vulnerabilities = new List<PackageVulnerability>();

        try
        {
            // Use dotnet list package --vulnerable to check for vulnerabilities
            var processInfo = new ProcessStartInfo
            {
                FileName = "dotnet",
                Arguments = "package root --vulnerable",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = _rootPath,
                StandardOutputEncoding = System.Text.Encoding.UTF8,
                StandardErrorEncoding = System.Text.Encoding.UTF8
            };

            using var process = Process.Start(processInfo);
            if (process == null)
            {
                return vulnerabilities;
            }

            // Set a timeout to avoid hanging
            var outputTask = process.StandardOutput.ReadToEndAsync();
            if (!outputTask.Wait(TimeSpan.FromSeconds(5)))
            {
                // Timeout - kill process and return empty list
                try { process.Kill(); } catch { }
                return vulnerabilities;
            }

            var output = outputTask.Result;
            var exitedTask = process.WaitForExitAsync(cancellationToken);
            if (!exitedTask.Wait(TimeSpan.FromSeconds(2)))
            {
                try { process.Kill(); } catch { }
            }

            // Parse output to find vulnerabilities for our specific package
            var vulnerabilityData = ParseVulnerabilityOutput(output, packageName, packageVersion);
            vulnerabilities.AddRange(vulnerabilityData);
        }
        catch (Exception)
        {
            // Silently ignore - vulnerability scanning is optional
        }

        return vulnerabilities;
    }

    /// <summary>
    /// Parses vulnerability output from dotnet CLI.
    /// </summary>
    private List<PackageVulnerability> ParseVulnerabilityOutput(
        string output,
        string packageName,
        string packageVersion)
    {
        var vulnerabilities = new List<PackageVulnerability>();

        if (string.IsNullOrWhiteSpace(output))
        {
            return vulnerabilities;
        }

        // Basic parsing - look for vulnerability indicators in the output
        var lines = output.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        
        foreach (var line in lines)
        {
            // Match lines containing our package name and indication of vulnerabilities
            if (line.Contains(packageName, StringComparison.OrdinalIgnoreCase) &&
                (line.Contains("vulnerable", StringComparison.OrdinalIgnoreCase) ||
                 line.Contains("CVE", StringComparison.OrdinalIgnoreCase)))
            {
                // Create a vulnerability entry based on the detected vulnerability
                // This is a conservative approach - we mark the version as having a vulnerability
                vulnerabilities.Add(new PackageVulnerability
                {
                    PackageName = packageName,
                    AffectedVersion = packageVersion,
                    VulnerabilityId = ExtractCveId(line) ?? "UNKNOWN",
                    Description = "Known vulnerability detected (run dotnet package root --vulnerable for details)",
                    Severity = ExtractSeverity(line),
                    AdvisoryUrl = $"https://www.nuget.org/packages/{packageName}/{packageVersion}",
                    PublishedDate = DateTime.UtcNow
                });
            }
        }

        return vulnerabilities;
    }

    /// <summary>
    /// Extracts CVE ID from output line if present.
    /// </summary>
    private string? ExtractCveId(string line)
    {
        var cveMatch = Regex.Match(line, @"CVE-\d{4}-\d+");
        return cveMatch.Success ? cveMatch.Value : null;
    }

    /// <summary>
    /// Extracts severity level from output.
    /// </summary>
    private string ExtractSeverity(string line)
    {
        if (line.Contains("critical", StringComparison.OrdinalIgnoreCase))
            return "Critical";
        if (line.Contains("high", StringComparison.OrdinalIgnoreCase))
            return "High";
        if (line.Contains("moderate", StringComparison.OrdinalIgnoreCase))
            return "Moderate";
        if (line.Contains("low", StringComparison.OrdinalIgnoreCase))
            return "Low";
        
        return "Unknown";
    }

    /// <summary>
    /// Checks if a package version matches the affected version constraint.
    /// </summary>
    private bool VersionMatches(string packageVersion, string affectedVersion)
    {
        // Simple equality check - in production this would use semantic versioning logic
        return packageVersion.Equals(affectedVersion, StringComparison.OrdinalIgnoreCase);
    }
}
